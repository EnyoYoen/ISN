from enum import Enum
import random

import numpy as np
import matplotlib.pyplot as plt

from Perlin import Perlin
from model.Structures import StructureType, Ore, OreType 
from Geometry import Point

class Biomes(Enum):
    LAVA = 1
    VOLCANO = 2
    PLAIN = 3
    MUSHROOM_FOREST = 4
    DESOLATED_FOREST = 5
    SNOW = 6

class Map:
    __slots__ = ["perlin", "map_chunks", "ores", "occupied_coords", "area_size", "chunk_coords"]

    def __init__(self, seed = 1) -> None:
        self.perlin = Perlin(seed, 4, 2, 2, 100, 1)
        self.map_chunks = {}
        self.ores = {} # {Point (chunk coords): {OreType: Point}} TODO : Maybe change to {Point (chunk coords): {OreType: Ore}}
        self.occupied_coords = {} # {Point: (Structure, StructureType)}
        self.area_size = 5 # The size (in chunks) of the area generated by get_area_around_chunk
        self.chunk_coords = Point.origin() # TODO : initialize with saved data (if it exists)
    
    def change_chunk_coords(self, chunk_coords):
        self.chunk_coords = chunk_coords

    def try_generate_ore(self, chunk_coords, position, treshold, search_area_size, search_ores, ores_count_treshold, ore_type):
        if random.random() < treshold:
            ores_count = 0
            values = [0]
            for i in range(1, search_area_size // 2 + 1):
                values.append(-i)
                values.append(i)
            for i in range(search_area_size * search_area_size):
                chunk_ores = self.ores.get(Point(chunk_coords.x + values[i // search_area_size], chunk_coords.y + values[i % search_area_size]), None)
                if chunk_ores != None:
                    for search_ore in search_ores:
                        actual_chunk_ores = chunk_ores.get(search_ore, None)
                        if actual_chunk_ores != None:
                            ores_count += len(actual_chunk_ores)
            if ores_count < ores_count_treshold:
                if self.ores.get(chunk_coords, None) == None:
                    self.ores[chunk_coords] = {}
                if self.ores[chunk_coords].get(ore_type, None) == None:
                    self.ores[chunk_coords][ore_type] = []

                ore = Ore(ore_type, position)
                found = False
                i = 0
                while not found and i < len(ore.points):
                    if self.occupied_coords.get(ore.points[i], None) != None:
                        found = True
                    i += 1

                if not found:
                    self.ores[chunk_coords][ore_type].append(position)
                    # TODO: maybe remove the code below in favor of self.ores?
                    absolute_chunk_origin = Point(chunk_coords.x * Perlin.CHUNK_SIZE, chunk_coords.y * Perlin.CHUNK_SIZE)
                    for point in ore.points:
                        self.occupied_coords[absolute_chunk_origin + position + point] = (ore, StructureType.ORE)

    def process_chunk(self, chunk_data, chunk_coords):
        processed_chunk = np.empty((Perlin.CHUNK_SIZE, Perlin.CHUNK_SIZE))
        for i in range(Perlin.CHUNK_SIZE):
            for j in range(Perlin.CHUNK_SIZE):
                height = chunk_data[i][j]
                position = Point(i, j)
                if height > 3.5:
                    processed_chunk[i][j] = Biomes.SNOW.value
                    self.try_generate_ore(chunk_coords, position, 0.005, 3, [OreType.CRYSTAL], 3, OreType.CRYSTAL)
                elif height > 2:
                    processed_chunk[i][j] = Biomes.DESOLATED_FOREST.value
                    self.try_generate_ore(chunk_coords, position, 0.01, 1, [OreType.COPPER], 2, OreType.COPPER)
                elif height > 1:
                    processed_chunk[i][j] = Biomes.MUSHROOM_FOREST.value
                elif height > -2:
                    processed_chunk[i][j] = Biomes.PLAIN.value
                    self.try_generate_ore(chunk_coords, position, 0.015, 1, [OreType.IRON], 2, OreType.IRON)
                elif height > -3:
                    processed_chunk[i][j] = Biomes.VOLCANO.value
                    self.try_generate_ore(chunk_coords, position, 0.005, 5, [OreType.VULCAN], 1, OreType.VULCAN)
                else:
                    processed_chunk[i][j] = Biomes.LAVA.value
        return processed_chunk

    def get_area_around_chunk(self):
        # Get an area of <area_size> x <area_size> chunks around the current chunk, concatenated into one 2D array
        rows = []
        chunks = []
        for i in range(self.area_size * self.area_size):
            actual_chunk_coords = Point(self.chunk_coords.x + i // self.area_size - 1, self.chunk_coords.y + i % self.area_size - 1)
            if self.map_chunks.get(actual_chunk_coords, None) == None:
                chunk = self.perlin.get_chunk(actual_chunk_coords.x, actual_chunk_coords.y)
                processed_chunk = self.process_chunk(chunk[0], actual_chunk_coords)
                self.map_chunks[actual_chunk_coords] = processed_chunk

            # Temporary (and inefficient)
            complete_chunk = self.map_chunks[actual_chunk_coords]
            for coord, struct in self.occupied_coords.items():
                if struct[1] == StructureType.ORE and actual_chunk_coords.x * Perlin.CHUNK_SIZE <= coord.x and coord.x < (actual_chunk_coords.x + 1) * Perlin.CHUNK_SIZE and actual_chunk_coords.y * Perlin.CHUNK_SIZE <= coord.y and coord.y < (actual_chunk_coords.y + 1) * Perlin.CHUNK_SIZE:
                    complete_chunk[coord.x - actual_chunk_coords.x * Perlin.CHUNK_SIZE][coord.y - actual_chunk_coords.y * Perlin.CHUNK_SIZE] = struct[0].type.value + 5

            chunks.append(complete_chunk)
            if i % self.area_size == self.area_size - 1:
                rows.append(np.concatenate(chunks, axis = 1))
                chunks.clear()
        
        return np.concatenate(rows, axis = 0)

if __name__ == "__main__":
    map = Map()
    area = map.get_area_around_chunk()
    fig, ax = plt.subplots()
    ax.imshow(area)
    plt.show()