from enum import Enum
import random

import numpy as np
import matplotlib.pyplot as plt

from Perlin import Perlin
from Structure import StructureType, Ore, OreType 
from Geometry import Point

class Biomes(Enum):
    LAVA = 1
    VOLCANO = 2
    PLAIN = 3
    MUSHROOM_FOREST = 4
    DESOLATED_FOREST = 5
    SNOW = 6

# TODO : Replace all tuple of coords (x, y) by Point
class Map:
    __slots__ = ["perlin", "map_chunks", "ores", "occupied_coords", "area_size", "x_chunk", "y_chunk"]

    def __init__(self, seed = 1) -> None:
        self.perlin = Perlin(seed, 4, 2, 2, 100, 1)
        self.map_chunks = {}
        self.ores = {} # {(x_chunk, y_chunk): {type: (x, y)}}
        self.occupied_coords = {} # {Point: (Structure, StructureType)}
        self.area_size = 5 # The size (in chunks) of the area generated by get_area_around_chunk
        self.x_chunk = 0 # TODO : initialize with saved data (if it exists)
        self.y_chunk = 0
    
    def change_chunk_coords(self, x, y):
        self.x_chunk = x
        self.y_chunk = y

    def try_generate_ore(self, x_chunk, y_chunk, x, y, treshold, search_area_size, search_ores, ores_count_treshold, ore_type):
        if random.random() < treshold:
            ores_count = 0
            values = [0]
            for i in range(1, search_area_size // 2 + 1):
                values.append(-i)
                values.append(i)
            for i in range(search_area_size * search_area_size):
                chunk_ores = self.ores.get((x_chunk + values[i // search_area_size], y_chunk + values[i % search_area_size]), None)
                if chunk_ores != None:
                    for search_ore in search_ores:
                        actual_chunk_ores = chunk_ores.get(search_ore, None)
                        if actual_chunk_ores != None:
                            ores_count += len(actual_chunk_ores)
            if ores_count < ores_count_treshold:
                if self.ores.get((x_chunk, y_chunk), None) == None:
                    self.ores[(x_chunk, y_chunk)] = {}
                if self.ores[(x_chunk, y_chunk)].get(ore_type, None) == None:
                    self.ores[(x_chunk, y_chunk)][ore_type] = []
                    
                pos = Point(x, y)
                ore = Ore(ore_type, pos)
                found = False
                i = 0
                while not found and i < len(ore.points):
                    if self.occupied_coords.get(ore.points[i], None) != None:
                        found = True
                    i += 1

                if not found:
                    self.ores[(x_chunk, y_chunk)][ore_type].append((x, y))
                    absolute_chunk_origin = Point(x_chunk * Perlin.CHUNK_SIZE, y_chunk * Perlin.CHUNK_SIZE)
                    for point in ore.points:
                        self.occupied_coords[absolute_chunk_origin + pos + point] = (ore, StructureType.ORE)

    def process_chunk(self, chunk_data, min_height, max_height, x_chunk, y_chunk):
        processed_chunk = np.empty((Perlin.CHUNK_SIZE, Perlin.CHUNK_SIZE))
        for i in range(Perlin.CHUNK_SIZE):
            for j in range(Perlin.CHUNK_SIZE):
                normalized_height = chunk_data[i][j]#(chunk_data[i][j] - min_height) / (max_height - min_height)
                if normalized_height > 3.5:
                    processed_chunk[i][j] = Biomes.SNOW.value
                    self.try_generate_ore(x_chunk, y_chunk, i, j, 0.005, 3, [OreType.CRYSTAL], 3, OreType.CRYSTAL)
                elif normalized_height > 2:
                    processed_chunk[i][j] = Biomes.DESOLATED_FOREST.value
                    self.try_generate_ore(x_chunk, y_chunk, i, j, 0.01, 1, [OreType.COPPER], 2, OreType.COPPER)
                elif normalized_height > 1:
                    processed_chunk[i][j] = Biomes.MUSHROOM_FOREST.value
                elif normalized_height > -2:
                    processed_chunk[i][j] = Biomes.PLAIN.value
                    self.try_generate_ore(x_chunk, y_chunk, i, j, 0.015, 1, [OreType.IRON], 2, OreType.IRON)
                elif normalized_height > -3:
                    processed_chunk[i][j] = Biomes.VOLCANO.value
                    self.try_generate_ore(x_chunk, y_chunk, i, j, 0.005, 5, [OreType.VULCAN], 1, OreType.VULCAN)
                else:
                    processed_chunk[i][j] = Biomes.LAVA.value
        return processed_chunk

    def get_area_around_chunk(self):
        # Get an area of <area_size> x <area_size> chunks around the current chunk, concatenated into one 2D array
        rows = []
        chunks = []
        for i in range(self.area_size * self.area_size):
            actual_chunk_x = self.x_chunk + i // self.area_size - 1
            actual_chunk_y = self.y_chunk + i % self.area_size - 1
            if self.map_chunks.get((actual_chunk_x, actual_chunk_y), None) == None:
                chunk = self.perlin.get_chunk(actual_chunk_x, actual_chunk_y)
                processed_chunk = self.process_chunk(chunk[0], chunk[1], chunk[2], actual_chunk_x, actual_chunk_y)
                self.map_chunks[actual_chunk_x, actual_chunk_y] = processed_chunk

            # Temporary
            complete_chunk = self.map_chunks[(actual_chunk_x, actual_chunk_y)]
            for coord, struct in self.occupied_coords.items():
                if struct[1] == StructureType.ORE and actual_chunk_x * Perlin.CHUNK_SIZE <= coord.x and coord.x < (actual_chunk_x + 1) * Perlin.CHUNK_SIZE and actual_chunk_y * Perlin.CHUNK_SIZE <= coord.y and coord.y < (actual_chunk_y + 1) * Perlin.CHUNK_SIZE:
                    complete_chunk[coord.x - actual_chunk_x * Perlin.CHUNK_SIZE][coord.y - actual_chunk_y * Perlin.CHUNK_SIZE] = struct[0].type.value + 5

            chunks.append(complete_chunk)
            if i % self.area_size == self.area_size - 1:
                rows.append(np.concatenate(chunks, axis = 1))
                chunks.clear()
        
        return np.concatenate(rows, axis = 0)

if __name__ == "__main__":
    map = Map()
    area = map.get_area_around_chunk()
    fig, ax = plt.subplots()
    ax.imshow(area)
    plt.show()